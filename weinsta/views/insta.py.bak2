#!/usr/bin/env python
# coding: utf-8


from django.views.generic import TemplateView
from django.conf import settings
from django.utils import timezone
import requests
from .base import BaseViewMixin
from ..models import MediaType, SocialProviders, Author, Media
from urllib.parse import quote
from allauth.socialaccount.models import SocialAccount, SocialToken, SocialApp

import logging
import os
import simplejson as json

from allauth.socialaccount.providers import registry

log = logging.getLogger(__name__)

api_root = 'https://api.instagram.com/v1'


class InstaView(TemplateView, BaseViewMixin):

    def get(self, request, *args, **kwargs):
        medias = self.fetch_my_insta_favorites(commit=True)

        # r = requests.get('https://api.instagram.com/v1/media/shortcode/BYJJZ2tDs3i?access_token=%s' % token,
        #                  proxies=settings.PROXIES)
        # print(r.status_code)
        # print(r.headers)
        # print(r.json())
        # obj = r.json()

        # with open('./temp/img.json') as f:
        #     r = f.read()
        #
        # obj = json.loads(r)
        # print(obj)

        # img_low_url = obj['data']['images']['low_resolution']['url']
        # text = obj['data']['caption']['text']
        # insta_uname = obj['data']['caption']['from']['username']
        # kwargs['insta_uname'] = insta_uname
        # kwargs['text'] = text
        #
        # idx = img_low_url.rindex('.')
        # if idx > 0:
        #     file_ext = img_low_url[idx:]
        # else:
        #     file_ext = '.jpg'
        # print (file_ext)
        #
        # # uname = quote(request.user.username)
        # uname = request.user.username
        # media_root = settings.MEDIA_ROOT
        # user_path = os.path.join(media_root, uname)
        # filename = 'BYJJZ2tDs3i' + file_ext
        # full_path = os.path.join(user_path, filename)
        # if not os.path.exists(user_path):
        #     os.makedirs(user_path)  # TODO: add mode for permission
        # log.debug('data path: ' + media_root)
        # log.debug('user path: ' + user_path)
        # log.debug('full path: ' + full_path)
        #
        # if not os.path.exists(full_path):
        #     rf = requests.get(img_low_url)
        #     chunk_size = 512
        #     with open(full_path, 'wb') as fd:
        #         for chunk in rf.iter_content(chunk_size):
        #             fd.write(chunk)
        #     log.debug('Downloaded to %s' % full_path)
        #
        # kwargs['img'] = uname + '/' + filename

        return super(InstaView, self).get(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        context = super(InstaView, self).get_context_data(**kwargs)
        context['medias'] = Media.objects.all()
        print(context['medias'])
        return context

    def _get_my_insta_token(self):
        insta_id = 'instagram'
        token = None
        try:
            provider = registry.by_id(insta_id, self.request)
            log.debug('Provider is :' + str(provider))
            app = SocialApp.objects.get(provider=provider.id)
            acc = SocialAccount.objects.get(provider=provider.id, user=self.request.user)
            token = SocialToken.objects.get(app=app, account=acc)
        except KeyError as err:
            log.exception('Instagram provider is not installed.', err)
        except SocialApp.DoesNotExist:
            log.warn('Instagram app is not registered. Register it in admin console.')
        except SocialAccount.DoesNotExist:
            log.warn('Instagram account is not connected.')
        except SocialToken.DoesNotExist:
            log.warn('Instagram token is not obtained. Login with Instagram first.')

        if token is None:
            self.error('Token is not found. Check your registered APP and Instagram account.')

        if settings.DEBUG:
            print(token)
        return token

    def search_insta_by_location(self):
        pass

    def search_insta_by_tag(self, tags):
        pass

    def search_insta_by_user(self, username):
        pass

    def fetch_my_insta_favorites(self, commit=True):
        favorites = []
        endpoint = 'users/self/media/liked'
        # result = self._invoke_insta(endpoint)
        result = open(os.path.join('./temp', 'favorites.json')).read()
        result = json.loads(result)
        if not result:
            return []

        if 'error' in result:
            self.error(result['message'])
            return []

        for media in result['data']:
            m = self.fetch_medias(media, self.request.user, commit=commit)
            favorites.append(m)

        return favorites

    def fetch_medias(self, media_dict, user, commit=True):
        md = media_dict
        t = md['type']

        MEDIA_MODEL = Media
        # MEDIA_MODEL = Photo
        # if MediaType.from_str(t) == MediaType.VIDEO:
        #     MEDIA_MODEL = Video

        try:
            m = MEDIA_MODEL.objects.get(user=user, provider=SocialProviders.INSTAGRAM, rid=md['id'])
        except MEDIA_MODEL.DoesNotExist:
            m = MEDIA_MODEL(user=user, provider=SocialProviders.INSTAGRAM, rid=md['id'])

        m.type = MediaType.from_str(t)
        m.rlink = md['link']
        # m.user = user
        # m.provider = SocialProviders.INSTAGRAM
        # m.rid = media['id']
        m.rcode = self.get_insta_code_from_link(m.rlink)
        m.created_at = timezone.datetime.utcfromtimestamp(int(md['created_time']))
        m.tags = md['tags']

        # m.authors = self.convert_author(media['user'])

        caption = md['caption']
        if caption:
            m.text = md['caption'].get('text', None)
            owner = md['caption'].get('from', None)
            if owner:
                m.owner = owner.get('username', None)

        mentions = set()
        mentions.add(None)
        for u in md['users_in_photo']:
            mentions.add(u['user'].get('username', None))
        mentions.remove(None)
        m.mentions = ','.join(mentions)

        loc = md['location']
        if loc:
            m.location = loc.get('name', None)
            m.latitude = loc.get('latitude', None)
            m.longitude = loc.get('longitude', None)

        m.json = json.dumps(md)

        # if 'images' in md and not md.images:
        #     for v in md['images'].values():
        #         v['filename'] = ''
        #     m.images = json.dumps(md['images'])
        #
        # if 'videos' in md and not md.videos:
        #     for v in md['videos'].values():
        #         v['filename'] = ''
        #     m.videos = json.dumps(md['videos'])

        if 'images' in md:
            if 'thumbnail' in md['images']:
                img = md['images']['thumbnail']
                m.thumb_width = int(img['width'])
                m.thumb_height = int(img['height'])
                self._download_media(m.thumb, img['url'])
        #     if 'low_resolution' in md['images']:
        #         img = md['images']['low_resolution']
        #         m.low_width = int(img['width'])
        #         m.low_height = int(img['height'])
        #         m.low_res = self._download_media(img['url'])
        #     if 'standard_resolution' in md['images']:
        #         img = md['images']['standard_resolution']
        #         m.standard_width = int(img['width'])
        #         m.standard_height = int(img['height'])
        #         m.standard_res = self._download_media(img['url'])
        #
        # if m.type == MediaType.VIDEO and 'videos' in md:
        #     if 'low_resolution' in md['videos']:
        #         img = md['videos']['low_resolution']
        #         m.video_low_width = int(img['width'])
        #         m.video_low_height = int(img['height'])
        #         m.video_low_res = self._download_media(img['url'])
        #     if 'standard_resolution' in md['videos']:
        #         img = md['videos']['standard_resolution']
        #         m.video_standard_width = int(img['width'])
        #         m.video_standard_height = int(img['height'])
        #         m.video_standard_res = self._download_media(img['url'])

        if commit:
            m.save()

        return m

    # def fetch_media_instances(self, media, commit=True):
    #     media_instances = []
    #
    #     m = media
    #     md = json.loads(m.json)
    #
    #     if
    #
    #
    #
    #     # if 'images' in media_dict:
    #     #     for res_str, img in media_dict['images'].items():
    #     #         res = MediaResolution.from_str(res_str)
    #     #         if res in media_dict:
    #     #             continue
    #     #
    #     #         obj = MediaInstance()
    #     #         obj.media = media
    #     #         obj.type = MediaType.PHOTO
    #     #         obj.media_code = media.rcode
    #     #         obj.width = int(img['width'])
    #     #         obj.height = int(img['height'])
    #     #         obj.link = img['url']
    #     #         obj.resolution = res
    #     #         obj.instance = self._download_media(obj.link)
    #     #         media_instances.append(object)
    #     #         if commit:
    #     #             obj.save()
    #     #
    #     # if 'videos' in media_dict:
    #     #     for res_str, video in media_dict['videos'].items():
    #     #         res = MediaResolution.from_str(res_str)
    #     #         if res in media_dict:
    #     #             continue
    #     #
    #     #         obj = MediaInstance()
    #     #         obj.media = media
    #     #         obj.type = MediaType.VIDEO
    #     #         obj.width = int(video['width'])
    #     #         obj.height = int(video['height'])
    #     #         obj.link = video['url']
    #     #         obj.resolution = res
    #     #         obj.instance = self._download_media(obj.link)
    #     #         media_instances.append(object)
    #     #         if commit:
    #     #             obj.save()
    #
    #     return media_instances

    def convert_author(self, author_dict):
        pass

    def get_insta_code_from_link(self, link):
        code = link.split('/')[-2]
        return code

    def _invoke_insta(self, endpoint, *args, **kwargs):
        token = self._get_my_insta_token()
        url = '%s/%s/?access_token=%s' % (api_root, endpoint, token)
        r = requests.get(url, proxies=settings.PROXIES)
        log.debug(r.status_code)
        log.debug(r.headers)
        log.debug(r.content)
        print(r.content)
        obj = r.json()
        if 200 > r.status_code or r.status_code >= 400:
            obj = {
                "code": obj['meta']['code'],
                "error": obj['meta']['error_type'],
                "message": obj['meta']['error_message']
            }
            log.error('%d %s. "%s". %s' % (r.status_code, r.reason, endpoint, obj['message']))
        return obj

    def _create_author(self):
        pass

    def _download_media(self, file_field, url):
        log.debug('Downloading %s' % url)
        r = requests.get(url, stream=True, proxies=settings.PROXIES)

        if r.status_code != requests.codes.ok:
            log.error('%d %s. Downloading %s' % (r.status_code, r.reason, url))
            return None

        file_name = url.split('/')[-1]

        file_field.save(file_name, r.raw)

